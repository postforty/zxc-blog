# 방문자 수 집계 전략

현재 방문자 수 집계 방식은 매우 기본적인 수준으로, 페이지가 로드될 때마다 카운트를 증가시킵니다. 이 문서는 짧은 시간 내에 동일한 사용자가 여러 번 집계되는 것을 방지하기 위한 더 안정적이고 표준적인 전략들을 설명합니다.

## 1. IP 주소 기반 추적

-   **작동 방식:** 방문자의 IP 주소와 마지막 방문 타임스탬프를 저장합니다. 동일한 IP 주소로부터 특정 시간(예: 24시간)이 지난 후에 발생한 방문만 새로운 방문으로 집계합니다.
-   **장점:**
    -   백엔드에서 비교적 간단하게 구현할 수 있습니다.
    -   클라이언트 측 저장소에 의존하지 않습니다.
-   **단점:**
    -   **개인정보 보호 문제:** IP 주소 저장은 개인정보 보호(예: GDPR)에 영향을 줄 수 있습니다. IP는 해싱하거나 서브넷만 저장하는 등 익명화해야 합니다.
    -   **유동 IP:** 많은 사용자가 IP 주소가 변경될 수 있는 유동 IP를 사용하므로, 실제보다 더 많이 집계될 수 있습니다.
    -   **공유 IP:** 사무실, 대학 또는 NAT 환경 등에서 여러 사용자가 동일한 IP 주소를 공유할 수 있어, 실제보다 더 적게 집계될 수 있습니다.

## 2. 세션 기반 추적

-   **작동 방식:** 사용자가 처음 방문하면 백엔드에서 세션을 생성하고 세션 ID를 클라이언트에게 쿠키 형태로 전송합니다. 이후의 모든 요청에 이 세션 ID가 포함됩니다. 백엔드는 이 ID를 사용하여 세션이 유지되는 동안 사용자를 식별하고 한 명의 방문자로 집계합니다. 새로운 세션이 시작될 때만 새로운 방문으로 집계됩니다.
-   **장점:**
    -   단일 사용자의 브라우징 세션을 식별하는 데 IP 추적보다 더 정확합니다.
    -   표준적이고 널리 사용되는 웹 기술입니다.
-   **단점:**
    -   세션은 만료될 수 있습니다. 사용자가 세션 만료 후 다시 방문하면 새로운 방문자로 집계됩니다. 이는 "일일" 방문자 수를 집계하는 데는 적합할 수 있지만, "전체 순 방문자"를 집계하는 데는 적합하지 않을 수 있습니다.

## 3. 영구 쿠키 / 클라이언트 사이드 핑거프린팅

-   **작동 방식:** 사용자가 처음 방문하면 프론트엔드에서 고유 식별자("핑거프린트")를 생성하여 브라우저의 `localStorage`나 영구 쿠키에 저장합니다. 이 ID는 모든 방문 시 백엔드로 전송됩니다. 백엔드는 이 ID를 이전에 본 적이 있는지 확인하여 새로운 순 방문으로 집계할지 여부를 결정합니다.
-   **장점:**
    -   장기간에 걸쳐 동일한 브라우저를 정확하게 식별할 수 있습니다.
-   **단점:**
    -   사용자가 쿠키나 로컬 스토리지를 지우면 새로운 방문자로 나타나게 됩니다.
    -   동일한 사용자의 다른 브라우저나 기기에서는 작동하지 않습니다.
    -   광고 차단기나 브라우저 개인정보 보호 설정에 의해 이 메커니즘이 차단될 수 있습니다.

---

## JWT 아키텍처와의 호환성 고려

현재 이 프로젝트는 인증에 JWT(JSON Web Token)를 사용하고 있습니다. JWT는 서버에 상태를 저장하지 않는 **무상태(Stateless)** 아키텍처를 지향합니다.

반면, 위에서 언급된 `세션 기반 추적`은 `express-session`과 같이 서버에 세션 데이터를 저장하는 **상태 저장(Stateful)** 방식입니다. 인증은 무상태로 처리하면서 방문자 추적만을 위해 상태 저장 방식을 도입하는 것은 다음과 같은 비효율을 야기할 수 있습니다.

-   **아키텍처의 불일치:** 프로젝트 전체의 기술 스택이 무상태(stateless)라는 일관성을 해치게 됩니다.
-   **관리 복잡성 증가:** 인증을 위한 JWT와 방문자 추적을 위한 세션을 동시에 관리해야 합니다.
-   **확장성 저하:** 서버 측 세션은 여러 서버 인스턴스로 확장할 때 세션 클러스터링 등 추가적인 고려가 필요합니다.

## 새로운 추천 접근 방식: 커스텀 "방문자용 JWT"

기존 JWT 아키텍처의 장점을 유지하면서 효율적으로 방문자를 추적하기 위해, **익명 방문자에게만 발급하는 별도의 JWT**를 활용하는 것을 새로운 방식으로 추천합니다.

-   **작동 방식:**
    1.  **방문자용 JWT 발급:** 사용자가 처음 사이트를 방문할 때 (그리고 "방문자용 토큰"이 없을 때), 백엔드는 이 사용자를 위한 고유 ID가 담긴 간단한 JWT를 생성합니다. 이 토큰은 인증용 JWT와는 무관한, 방문자 식별 전용 토큰입니다.
    2.  **쿠키로 전송:** 생성된 토큰을 쿠키에 담아 클라이언트에게 보냅니다.
    3.  **방문 기록 시 토큰 확인:** `/api/stats/visit` 엔드포인트가 호출되면, 백엔드는 먼저 이 "방문자용 토큰"이 요청에 포함되어 있는지 확인합니다.
        -   **토큰이 있다면:** 이미 방문한 사용자로 간주하고 카운트를 증가시키지 않습니다.
        -   **토큰이 없다면:** 새로운 방문자로 간주하여 카운트를 증가시키고, 새로운 "방문자용 토큰"을 발급하여 클라이언트에게 보냅니다.

-   **장점:**
    -   **무상태(Stateless) 구조 유지:** 서버에 세션 데이터를 저장할 필요가 없습니다.
    -   **효율성:** `express-session`과 같은 별도의 세션 라이브러리를 추가할 필요가 없습니다.
    -   **관심사 분리:** 사용자 인증과 익명 방문자 추적 로직을 명확하게 분리할 수 있습니다.

-   **토큰 만료 전략:**
    -   **목표:** "일일 방문자"를 달력 날짜 기준으로 정확하게 집계하기 위함입니다. 예를 들어, 한 사용자가 23:59분에 방문하고 2분 뒤인 다음 날 00:01분에 다시 방문했을 때, 각각 다른 날의 방문으로 집계되어야 합니다.
    -   **구현:** `visitor-token`의 만료 시간을 발급 시점으로부터 24시간으로 설정하는 대신, **현재 날짜의 자정(23:59:59)**으로 설정합니다.
    -   이렇게 하면 날짜가 바뀌는 순간 토큰이 만료되므로, 다음 날의 첫 방문은 항상 새로운 방문으로 기록됩니다.

이 방식은 기존 아키텍처와의 일관성을 유지하면서, 중복 집계 문제를 해결하는 가장 현대적이고 효율적인 방법입니다.